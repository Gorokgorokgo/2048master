### 1. 비즈니스 로직 구현

- 모든 비즈니스 로직은 반드시 **테스트 코드를 먼저 작성**한 후 구현합니다.
- **SOLID 원칙**을 따릅니다.
- **Clean Architecture**에 따라 계층을 분리하여 구현합니다.
- IaC 구성 시에는 **Pulumi**나 **CloudFormation**에서 사용하는 `Description`을 명료하게 작성합니다.

---

### 2. 코드 품질 원칙

- **단순성 우선**: 복잡한 솔루션보다 가장 단순한 솔루션을 우선적으로 고려합니다.
- **중복 배제(DRY)**: 중복 로직은 최소화하고, 가능한 기능은 재사용 가능하게 구성합니다.
- **테스트 순수성 보장**: 테스트 외에는 개발이나 프로덕션 환경에서의 외부 데이터를 사용하지 않습니다.
- **명령형 프로그래밍 지양**: 명령형 로직 대신 함수형 스타일을 고려하며, 로직 분기를 최소화하여 코드 복잡도를 낮춥니다.

---

### 3. 리팩토링

- 리팩토링이 필요할 경우 **구체적인 계획을 문서화**하고 동의를 받아 단계적으로 진행합니다.
- 리팩토링은 **기능 변경이 아닌 구조 개선**에 집중합니다.
- 리팩토링 후에는 반드시 **기존 테스트가 통과**되는 것을 확인합니다.

---

### 4. 대시보드 및 시각화

- 대시보드는 **실제 운영 환경에서 필요한 항목만**을 엄선하여 구성합니다.
- **과도한 차트, 색상, 애니메이션**을 지양하고, **직관적인 UI/UX 구성**을 우선합니다.
- **Mermaid** 등을 사용할 때에는 사용자가 쉽게 이해할 수 있는 구조로 작성합니다.
- **자동화된 다이어그램 생성 도구**를 도입하는 경우, svg나 이미지가 아닌 **소스 기반 스크립트**로 관리합니다.

---

### 5. 네이밍 및 설계 원칙

- 도메인 계층의 용어는 **비즈니스 의미를 기준**으로 설계합니다.
- 메서드는 **행위 중심의 이름**을 가지며, 이름만으로 목적을 이해할 수 있어야 합니다.
- 비즈니스 의사결정은 도메인 계층에서 수행되며, 애플리케이션 계층은 흐름 제어 역할만 수행합니다.
- 컨트롤러는 인증, 파라미터 처리, 응답 포맷 처리 등 **얇은 역할만 담당**해야 합니다.

---

### 6. 예외 처리 및 로깅

- 예외는 **비즈니스 예외 / 시스템 예외 / 외부 연동 예외**로 명확히 구분합니다.
- 로그는 **적절한 수준에서만** 출력하며, 개인정보는 절대 포함하지 않습니다.
- 예외 메시지는 **사용자에게 전달 가능한 형태와 내부 디버깅용 메시지를 구분**합니다.

---

### 7. Git / CI/CD 원칙

- 브랜치는 `feature/`, `bugfix/`, `refactor/`, `hotfix/` 등으로 prefix를 명확히 구분합니다.
- 커밋 메시지는 **Conventional Commits**를 따릅니다.

  예: `feat: 유저 생성 기능 추가`, `fix: 중복 등록 오류 수정`

- PR 전에는 **모든 테스트가 통과**되어야 하며, 최소 1명 이상의 코드 리뷰를 받아야 합니다.

---

### 8. 지속적 개선 문화

- 반복되는 패턴이나 규칙은 **팀의 규칙으로 승격**하고, 문서화하여 공유합니다.
- 레거시 코드나 미흡한 구조는 **기능 추가 시 리팩토링을 병행**하여 점진적으로 개선합니다.
- 구조적 변경은 반드시 **이유, 대안, 영향 범위**를 공유한 뒤에 도입합니다.
